class WeatherViewModel @Inject constructor(
    private val repository: WeatherRepository,
    private val weatherDatabase: WeatherDatabase
) : ViewModel() {

    private val _weatherData = MutableLiveData<Resource<WeatherResponse>>()
    val weatherData: LiveData<Resource<WeatherResponse>> get() = _weatherData

    private val _hourlyData = MutableLiveData<Resource<ForecastResponse>>()
    val hourlyData: LiveData<Resource<ForecastResponse>> get() = _hourlyData


    private val _forecastData = MutableLiveData<Resource<List<DailyForecast>>>()
    val forecastData: LiveData<Resource<List<DailyForecast>>> get() = _forecastData


    private fun consolidateForecastData(forecastResponse: ForecastResponse): List<DailyForecast> {
        val dailyForecasts = mutableListOf<DailyForecast>()

        // Group the forecast items by day
        val groupedForecasts = forecastResponse.list.groupBy { forecastItem ->
            forecastItem.dtTxt.substringBefore(" ") // Extract the date part
        }

        // Calculate high and low temperatures, weather description, and other properties for each day
        for ((date, forecasts) in groupedForecasts) {
            val highTemp = forecasts.maxByOrNull { it.main.tempMax }?.main?.tempMax ?: 0.0
            val lowTemp = forecasts.minByOrNull { it.main.tempMin }?.main?.tempMin ?: 0.0
            val weatherDescription =
                forecasts.firstOrNull()?.weather?.getOrNull(0)?.description ?: ""
            val weatherIcon = forecasts.firstOrNull()?.weather?.getOrNull(0)?.icon ?: ""
            val rainForecast = forecasts.firstOrNull()?.rain
            val chanceOfRain = convertRainToPercentage(rainForecast)
            val humidity = forecasts.firstOrNull()?.main?.humidity ?: 0
            val feelsLikeTemperature = forecasts.firstOrNull()?.main?.feelsLike ?: 0.0
            val windSpeed = forecasts.firstOrNull()?.wind?.speed ?: 0.0
            val windDeg = forecasts.firstOrNull()?.wind?.deg ?: 0

            dailyForecasts.add(
                DailyForecast(
                    date = date,
                    highTemperature = highTemp,
                    lowTemperature = lowTemp,
                    weatherDescription = weatherDescription,
                    weatherIcon = weatherIcon,
                    chanceOfRain = chanceOfRain.toDouble(),
                    humidity = humidity,
                    feelsLikeTemperature = feelsLikeTemperature,
                    windSpeed = windSpeed,
                    windDeg = windDeg,
                    cityName = forecastResponse.city.name
                )
            )
        }
        return dailyForecasts
    }


    suspend fun fetchWeatherData(latitude: Double, longitude: Double) =
        withContext(Dispatchers.IO) {
            // Update LiveData on the Main thread
            withContext(Dispatchers.Main) {
                _weatherData.value = Resource.Loading()
            }

            // Prune old database entries
            withContext(Dispatchers.IO) {
                pruneOldDatabaseEntries(
                    getCount = { weatherDatabase.weatherDataDao().getCount() },
                    deleteOldestEntry = { weatherDatabase.weatherDataDao().deleteOldestEntry() }
                )
            }

            // Prepare blocks for network fetch and cache operations
            val fetchBlock: suspend () -> Response<WeatherResponse> = {
                repository.getWeatherData(ApiConfig.APP_ID, latitude, longitude)
            }

            val cacheBlock: suspend (WeatherResponse) -> Unit = { weatherResponseBody ->
                val weatherDataEntity = WeatherDataEntity(
                    latitude = latitude,
                    longitude = longitude,
                    weatherJson = Gson().toJson(weatherResponseBody)
                )
                weatherDatabase.weatherDataDao().insertWeatherData(weatherDataEntity)
            }

            // Fetch and cache data
            val result = fetchAndCacheData(fetchBlock, cacheBlock)

            // Update LiveData on the Main thread
            withContext(Dispatchers.Main) {
                _weatherData.value = result
            }

            Log.i("MOH!", "Current Running on thread: ${Thread.currentThread().name}")
        }


    suspend fun fetchHourlyData(latitude: Double, longitude: Double) = withContext(Dispatchers.IO) {
        // Update LiveData on the Main thread
        withContext(Dispatchers.Main) {
            _hourlyData.value = Resource.Loading()
            Log.i("MOH!", "Setting LiveData to Loading")
        }

        // Prune old database entries
        withContext(Dispatchers.IO) {
            Log.i("MOH!", "Pruning old database entries")
            pruneOldDatabaseEntries(
                getCount = { weatherDatabase.hourlyWeatherDao().getCount() },
                deleteOldestEntry = { weatherDatabase.hourlyWeatherDao().deleteOldestEntry() }
            )

            val currentCount = weatherDatabase.hourlyWeatherDao().getCount()
            Log.i("MOH!", "After: Total number of hourly entries: $currentCount")
        }

        // Check for existing cached data
        // Check for existing cached data
        val cachedData = weatherDatabase.hourlyWeatherDao().getHourlyWeather(latitude, longitude)
        if (cachedData != null) {
            Log.i("MOH!", "Using cached data")
            // Deserialize the cached data
            val forecastResponse = Gson().fromJson(cachedData.hourlyWeatherJson, ForecastResponse::class.java)
            // Update LiveData
            withContext(Dispatchers.Main) {
                _hourlyData.value = Resource.Success(forecastResponse)
            }
            return@withContext
        }


        // Prepare blocks for network fetch and cache operations
        val fetchBlock: suspend () -> Response<ForecastResponse> = {
            Log.i("MOH!", "Fetching data from API")
            repository.getForecastData(ApiConfig.APP_ID, latitude, longitude)
        }

        val cacheBlock: suspend (ForecastResponse) -> Unit = { hourlyResponseBody ->
            Log.i("MOH!", "Caching API response")
            val hourlyWeatherEntity = HourlyWeatherEntity(
                latitude = latitude,
                longitude = longitude,
                hourlyWeatherJson = Gson().toJson(hourlyResponseBody)
            )
            weatherDatabase.hourlyWeatherDao().insertHourlyWeather(hourlyWeatherEntity)
        }

        // Fetch and cache data
        Log.i("MOH!", "Attempting to fetch and cache data")
        val result = fetchAndCacheData(fetchBlock, cacheBlock)

        // Update LiveData on the Main thread
        withContext(Dispatchers.Main) {
            Log.i("MOH!", "Setting LiveData with API or Cached Data")
            _hourlyData.value = result
        }

        Log.i("MOH!", "Current Running on thread: ${Thread.currentThread().name}")
    }


//    suspend fun fetchHourlyData(latitude: Double, longitude: Double) = withContext(Dispatchers.IO) {
//        // Update LiveData on the Main thread
//        withContext(Dispatchers.Main) {
//            _hourlyData.value = Resource.Loading()
//            Log.i("MOH!", "Setting LiveData to Loading")
//        }
//
//        // Prune old database entries
//        withContext(Dispatchers.IO) {
//            Log.i("MOH!", "Pruning old database entries")
//            pruneOldDatabaseEntries(
//                getCount = { weatherDatabase.hourlyWeatherDao().getCount() },
//                deleteOldestEntry = { weatherDatabase.hourlyWeatherDao().deleteOldestEntry() }
//            )
//
//            var currentCount = weatherDatabase.hourlyWeatherDao().getCount()
//            while (currentCount > 10) {
//                weatherDatabase.hourlyWeatherDao().deleteOldestEntry()
//                currentCount = weatherDatabase.hourlyWeatherDao().getCount()
//            }
//            Log.i("MOH!", "After: Total number of hourly entries: $currentCount")
//        }
//
//        // Prepare blocks for network fetch and cache operations
//        val fetchBlock: suspend () -> Response<ForecastResponse> = {
//            Log.i("MOH!", "Fetching data from API")
//            repository.getForecastData(ApiConfig.APP_ID, latitude, longitude)
//        }
//
//        val cacheBlock: suspend (ForecastResponse) -> Unit = { hourlyResponseBody ->
//            Log.i("MOH!", "Caching API response")
//            val hourlyWeatherEntity = HourlyWeatherEntity(
//                latitude = latitude,
//                longitude = longitude,
//                hourlyWeatherJson = Gson().toJson(hourlyResponseBody)
//            )
//            weatherDatabase.hourlyWeatherDao().insertHourlyWeather(hourlyWeatherEntity)
//        }
//
//        // Fetch and cache data
//        Log.i("MOH!", "Attempting to fetch and cache data")
//        val result = fetchAndCacheData(fetchBlock, cacheBlock)
//
//        // Update LiveData on the Main thread
//        withContext(Dispatchers.Main) {
//            Log.i("MOH!", "Setting LiveData with API or Cached Data")
//            _hourlyData.value = result
//        }
//
//        Log.i("MOH!", "Current Running on thread: ${Thread.currentThread().name}")
//    }



    suspend fun fetchForecastData(latitude: Double, longitude: Double) =
        withContext(Dispatchers.IO) {
            // Update LiveData on the Main thread
            withContext(Dispatchers.Main) {
                _forecastData.value = Resource.Loading()
            }

            // Prune old database entries
            withContext(Dispatchers.IO) {
                pruneOldDatabaseEntries(
                    getCount = { weatherDatabase.forecastDao().getCount() },
                    deleteOldestEntry = { weatherDatabase.forecastDao().deleteOldestEntry() }
                )
            }

            // Prepare blocks for network fetch and cache operations
            val fetchBlock: suspend () -> Response<ForecastResponse> = {
                repository.getForecastData(ApiConfig.APP_ID, latitude, longitude)
            }

            val cacheBlock: suspend (ForecastResponse) -> Unit = { forecastResponseBody ->
                val forecastEntity = ForecastEntity(
                    latitude = latitude,
                    longitude = longitude,
                    forecastJson = Gson().toJson(forecastResponseBody)
                )
                weatherDatabase.forecastDao().insertForecast(forecastEntity)
            }

            // Fetch and cache data
            val result = fetchAndCacheForecastData(fetchBlock, cacheBlock)

            // Update LiveData on the Main thread
            withContext(Dispatchers.Main) {
                _forecastData.value = result
            }

            Log.i("MOH!", "Current Running on thread: ${Thread.currentThread().name}")
        }

    private suspend fun <T> fetchAndCacheData(
        fetchBlock: suspend () -> Response<T>,
        cacheBlock: suspend (T) -> Unit
    ): Resource<T> = withContext(Dispatchers.IO) {
        try {
            val response = fetchBlock()
            return@withContext if (response.isSuccessful) {
                val responseBody = response.body()
                if (responseBody != null) {
                    cacheBlock(responseBody)
                    Log.i("DOH!", "Response is $responseBody")
                    Resource.Success(responseBody)
                } else {
                    Resource.Error("Null response body")
                }
            } else {
                Resource.Error("Error fetching data: ${response.code()}")
            }
        } catch (e: Exception) {
            Resource.Error("Error fetching data: ${e.message}")
        }
    }

    private suspend fun fetchAndCacheForecastData(
        fetchBlock: suspend () -> Response<ForecastResponse>,
        cacheBlock: suspend (ForecastResponse) -> Unit
    ): Resource<List<DailyForecast>> = withContext(Dispatchers.IO) {
        try {
            val response = fetchBlock()
            return@withContext if (response.isSuccessful) {
                val responseBody = response.body()
                if (responseBody != null) {
                    cacheBlock(responseBody)
                    val consolidatedData = consolidateForecastData(responseBody)
                    Resource.Success(consolidatedData)
                } else {
                    Resource.Error("Null response body")
                }
            } else {
                Resource.Error("Error fetching data: ${response.code()}")
            }
        } catch (e: Exception) {
            Resource.Error("Error fetching data: ${e.message}")
        }
    }

    private suspend fun pruneOldDatabaseEntries(
        getCount: suspend () -> Int,
        deleteOldestEntry: suspend () -> Unit
    ) = withContext(Dispatchers.IO) { // switch to IO dispatcher

        val initialCount = getCount()
        Log.i("MOH!", "Before: Total number of entries: $initialCount")
        Log.i("MOH!", "Running on thread: ${Thread.currentThread().name}")

        // Set a threshold below which you don't want to delete entries
        val threshold = 2

        // Calculate how many entries need to be deleted to reach the threshold
        val entriesToDelete = initialCount - threshold

        if (entriesToDelete > 0) {
            // Delete the oldest `entriesToDelete` entries
            repeat(entriesToDelete) {
                deleteOldestEntry()
            }

            // Optionally, you could verify the final count, but it's not strictly necessary
            val currentCount = getCount()
            Log.i("MOH!", "After: Total number of entries: $currentCount")
        } else {
            Log.i(
                "MOH!",
                "No need to prune entries. Current count is below or equal to the threshold."
            )
        }

        Log.i("MOH!", "Running on thread: ${Thread.currentThread().name}")
    }

}