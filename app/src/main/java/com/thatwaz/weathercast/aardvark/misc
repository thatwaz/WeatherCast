initial ui test
     binding.btnClear.setOnClickListener {
            binding.clTop.setBackgroundColor(Color.parseColor("#007ac1"))
            binding.apply {
                textView.setText("Clear")
                ivCloud.visibility = View.INVISIBLE
                ivNight.visibility = View.INVISIBLE
                textView.visibility = View.VISIBLE
                ivSun.visibility = View.VISIBLE
            }
        }


        binding.btnCloudy.setOnClickListener {
            binding.clTop.setBackgroundColor(Color.parseColor("#62757f"))
            binding.apply {
                textView.setText("Cloudy")
                textView.visibility = View.VISIBLE
                ivCloud.visibility = View.VISIBLE
                ivSun.visibility = View.INVISIBLE
                ivNight.visibility = View.INVISIBLE
            }
        }

        binding.btnNight.setOnClickListener {
            binding.clTop.setBackgroundColor(Color.parseColor("#000051"))
            binding.apply {
                textView.setText("Clear")
                textView.visibility = View.VISIBLE
                ivCloud.visibility = View.INVISIBLE
                ivSun.visibility = View.INVISIBLE
                ivNight.visibility = View.VISIBLE
            }
        }

    }

    ---------------- xml for ui test
        <androidx.constraintlayout.widget.ConstraintLayout
            android:id="@+id/cl_top"
            android:layout_width="match_parent"
            android:layout_height="300dp"
            android:background="@color/black"
            app:layout_constraintTop_toTopOf="parent">

            <ImageView
                android:id="@+id/iv_sun"
                android:layout_width="100dp"
                android:layout_height="100dp"
                android:visibility="invisible"
                app:layout_constraintStart_toStartOf="parent"
                app:layout_constraintTop_toTopOf="parent"
                app:srcCompat="@drawable/sun" />

            <ImageView
                android:id="@+id/iv_cloud"
                android:layout_width="100dp"
                android:layout_height="100dp"
                android:visibility="invisible"
                app:layout_constraintStart_toStartOf="parent"
                app:layout_constraintTop_toTopOf="parent"
                app:srcCompat="@drawable/cloudy" />

            <ImageView
                android:id="@+id/iv_night"
                android:layout_width="100dp"
                android:layout_height="100dp"
                android:visibility="gone"
                app:layout_constraintStart_toStartOf="parent"
                app:layout_constraintTop_toTopOf="parent"
                app:srcCompat="@drawable/moon" />

            <TextView
                android:id="@+id/textView"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Clear"
                android:visibility="invisible"
                android:textColor="@color/white"
                android:textSize="24sp"
                android:textStyle="bold"
                app:layout_constraintBottom_toBottomOf="@id/iv_sun"
                app:layout_constraintStart_toEndOf="@+id/iv_sun"
                app:layout_constraintTop_toTopOf="@id/iv_sun" />
        </androidx.constraintlayout.widget.ConstraintLayout>

        <Button
            android:id="@+id/btn_clear"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="clear sky"
            android:layout_marginTop="36dp"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintHorizontal_bias="0.5"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toBottomOf="@+id/cl_top" />

        <Button
            android:id="@+id/btn_cloudy"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="cloudy sky"
            android:layout_marginTop="36dp"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintHorizontal_bias="0.5"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toBottomOf="@+id/btn_clear" />

        <Button
            android:id="@+id/btn_night"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Night Time"
            android:layout_marginTop="36dp"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintHorizontal_bias="0.5"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toBottomOf="@+id/btn_cloudy" />


            -- fragment code --
            //            // Update the UI with the weather data
            //            // Use binding to access the views in your fragment layout
            //            binding.tvLocation.text = weatherData?.name
            //            binding.tvLat.text = "Lat = " +weatherData?.coord!!.lat.toString()
            //            binding.tvLon.text = "Lon = " +weatherData.coord.lon.toString()
            //
            //        }

                    //            binding.tvCurrentWeatherDescription.text = weatherData?.weather?.get(0)?.description
            //            val kelvinTemp = weatherData?.main!!.temp
            //            val fahrenheitTemp = kelvinTemp.let { (it - 273.15) * 9/5 + 32 }
            //            binding.tvCurrentTemperature.text = fahrenheitTemp.toInt().toString() + " \u00B0"
                    // ... update other views ...

            //        viewModel.sunriseTime.observe(viewLifecycleOwner) { sunriseTime ->
            //            Log.i("DOH!", "Sunrise Time: $sunriseTime")
            //        }

            //        viewModel.weatherData.observe(viewLifecycleOwner) { weatherResponse ->
            //            if (weatherResponse != null) {
            //                Log.i("DOH!", "Output is $weatherResponse")
            //            } else {
            //                Log.i("DOH!", "Failed to receive weather data or empty response")
            //            }
            //        }

            //            binding.tvCurrentWeatherDescription.text = weatherData?.weather?.get(0)?.description
            //            val kelvinTemp = weatherData?.main!!.temp
            //            val fahrenheitTemp = kelvinTemp.let { (it - 273.15) * 9/5 + 32 }
            //            binding.tvCurrentTemperature.text = fahrenheitTemp.toInt().toString() + " \u00B0"
                            // ... update other views ...



           //    private fun checkLocationPermissionsAndStartUpdates() {
           //        if (!isLocationEnabled()) {
           //            showToast("Your location provider is turned off, please turn it on")
           //            openLocationSettings()
           //        } else {
           //            requestLocationPermissions()
           //        }
           //    }

           //    private fun requestLocationPermissions() {
           //        Dexter.withContext(requireContext())
           //            .withPermissions(
           //                Manifest.permission.ACCESS_FINE_LOCATION,
           //                Manifest.permission.ACCESS_COARSE_LOCATION
           //            )
           //            .withListener(object : MultiplePermissionsListener {
           //                // Handle permissions callback as before
           //                // ...
           //                override fun onPermissionsChecked(report: MultiplePermissionsReport?) {
           //                    if (report?.areAllPermissionsGranted() == true) {
           //                        // Get the current location using the LocationRepository
           //                        locationRepository.getCurrentLocation { latitude, longitude ->
           //                            // Use the latitude and longitude to fetch the weather data
           //                            getLocationWeatherDetails(latitude, longitude)
           //                        }
           //                    }
           //                }
           //            })
           //            .onSameThread()
           //            .check()
           //    }

               private fun getLocationWeatherDetails(latitude: Double, longitude: Double) {
                   viewModel.fetchWeatherData(latitude, longitude)
                   // TODO: Implement fetching weather details using the provided latitude and longitude
               }




            ----------------------------------------


            kinda cool transparent background
            <?xml version="1.0" encoding="utf-8"?>
            <shape xmlns:android="http://schemas.android.com/apk/res/android">
                <solid android:color="#80000000" /> <!-- 80% black with some transparency (adjust as needed) -->
                <corners android:radius="4dp" /> <!-- Add rounded corners if you prefer -->
            </shape>




    private fun transformForecastData(weatherItems: List<WeatherItem>): List<DailyForecast> {
        val dailyForecasts = mutableListOf<DailyForecast>()

        val groupedByDay = weatherItems.groupBy { it.dtTxt.substring(0, 10) }

        for ((day, items) in groupedByDay) {
            val highTemperature = items.maxByOrNull { it.main.tempMax }?.main?.tempMax ?: 0.0
            val lowTemperature = items.minByOrNull { it.main.tempMin }?.main?.tempMin ?: 0.0
            val averageRain = items.mapNotNull { it.pop }.average()

            val morningItems = items.filter { it.dtTxt.contains("06:00:00") }
            val afternoonItems = items.filter { it.dtTxt.contains("12:00:00") }
            val eveningItems = items.filter { it.dtTxt.contains("18:00:00") }

            val morningWeather = morningItems.firstOrNull()?.weather?.get(0)?.description ?: ""
            val afternoonWeather = afternoonItems.firstOrNull()?.weather?.get(0)?.description ?: ""
            val eveningWeather = eveningItems.firstOrNull()?.weather?.get(0)?.description ?: ""

            val dailyForecast = DailyForecast(
                date = day,
                highTemperature = highTemperature,
                lowTemperature = lowTemperature,
                chanceOfRain = averageRain,
                morningWeather = morningWeather,
                afternoonWeather = afternoonWeather,
                eveningWeather = eveningWeather
            )

            dailyForecasts.add(dailyForecast)
        }

        return dailyForecasts
    }

        data class DailyForecast(
            val date: String,
            val highTemperature: Double,
            val lowTemperature: Double,
            val chanceOfRain: Double,
            val morningWeather: String,
            val afternoonWeather: String,
            val eveningWeather: String
        )
        \



            private fun updateWeatherUI(weatherData: WeatherResponse) {
                val pressureInhPa = weatherData.main.pressure
                val pressureInInHg = hPaToInHg(pressureInhPa)
                val pressureColor = getPressureColor(pressureInhPa)
                val currentConditions = weatherData.weather[0].description.capitalizeWords()
                val kelvinTemp = weatherData.main.temp
                val fahrenheitTemp = kelvinToFahrenheit(kelvinTemp)
                val humidityValue = weatherData.main.humidity
                val formattedHumidity = "$humidityValue%"
                val kelvinFeelsLikeTemp = weatherData.main.feelsLike
                val fahrenheitFeelsLikeTemp = kelvinToFahrenheit(kelvinFeelsLikeTemp).toString()
                val formattedFeelsLike = "$fahrenheitFeelsLikeTemp\u00B0"
                val windDirectionDegrees = weatherData.wind.deg
                val formattedWindDirection = getWindDirection(windDirectionDegrees)
                val visibilityInMeters = weatherData.visibility
                val visibilityInMiles = convertMetersToMiles(visibilityInMeters)
                val sunriseTime = convertUnixTimestampToTimeWithAMPM(weatherData.sys.sunrise.toLong())
                val sunsetTime = convertUnixTimestampToTimeWithAMPM(weatherData.sys.sunset.toLong())
                val imageIcon = weatherData.weather[0].icon

                setCurrentWeatherImage(imageIcon)
                setCurrentWeatherIcon(imageIcon)

                binding.apply {
                    tvLocation.text = weatherData.name
                    tvCurrentConditions.text = breakTextIntoLines(currentConditions, 18)
                    tvFeelsLike.text = formattedFeelsLike
                    tvCurrentTemperature.text = fahrenheitTemp.toString()
                    tvHumidity.text = formattedHumidity
                    tvWind.text = buildString {
                        append(formattedWindDirection)
                        append(" ")
                        append(ceil(weatherData.wind.speed).toInt())
                        append(" mph ")
                    }
                    tvAirPressure.text = String.format("%.2f", pressureInInHg.toDouble())
                    binding.tvAirPressure.paint?.isUnderlineText = true
                    binding.tvAirPressure.setTextColor(pressureColor)
                    binding.tvAirPressure.setOnClickListener {
                        val action = CurrentWeatherFragmentDirections
                            .actionCurrentWeatherFragmentToBarometricPressureDialogFragment()
                        findNavController().navigate(action)
                    }
                    tvVisibility.text = buildString {
                        append(visibilityInMiles)
                        append(" miles")
                    }
                    tvSunrise.text = sunriseTime
                    tvSunset.text = sunsetTime
                }
            }



class ForecastFragment : Fragment() {


    @Inject
    lateinit var viewModel: WeatherViewModel

    @Inject
    lateinit var locationRepository: LocationRepository

    private lateinit var bottomNavView: BottomNavigationView
    private lateinit var weatherDataHandler: WeatherDataHandler
//    private lateinit var locationRepository: LocationRepository

    private var _binding: FragmentForecastBinding? = null
    private val binding get() = _binding!!

    private var forecastAdapter: ForecastAdapter? = null

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        bottomNavView = activity?.findViewById(R.id.bnv_weather_cast) ?: return binding.root
        (activity?.application as WeatherCastApplication).appComponent.inject(this)
        _binding = FragmentForecastBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        val menuHost: MenuHost = requireActivity()

        menuHost.addMenuProvider(object : MenuProvider {
            override fun onCreateMenu(menu: Menu, menuInflater: MenuInflater) {
                menuInflater.inflate(R.menu.menu_refresh, menu)
            }

            override fun onMenuItemSelected(menuItem: MenuItem): Boolean {
                return when (menuItem.itemId) {
                    R.id.action_refresh -> {
                        refreshForecastWeatherData()
                        true
                    }
                    else -> false
                }
            }
        }, viewLifecycleOwner, Lifecycle.State.RESUMED)

        requestLocationData()
//        locationRepository = LocationRepository(
//            LocationServices.getFusedLocationProviderClient(requireContext())
//        )

        weatherDataHandler = WeatherDataHandler(requireContext(), viewModel)

        setupRecyclerView()
        fetchForecastData()


        viewModel.forecastData.observe(viewLifecycleOwner) { resource ->
            when (resource) {
                is Resource.Loading -> {
                    setWeatherDataVisibility(false)
                }
                is Resource.Success -> {
                    val dailyForecasts = resource.data
                    if (dailyForecasts != null) {
                        setWeatherDataVisibility(true)
                        binding.tvForecastLocation.text = dailyForecasts[0].cityName
                        updateRecyclerView(dailyForecasts)
                    }
                }
                is Resource.Error -> {
                    setWeatherDataVisibility(false)
                    val errorMessage = resource.errorMessage ?: "An error occurred"
                    displayErrorMessage(errorMessage)
                }
            }
        }
    }

    private fun requestLocationData() {
        locationRepository.getCurrentLocation { _, _ -> weatherDataHandler.requestLocationData() }
    }

    private fun displayErrorMessage(errorMessage: String) {
        Snackbar.make(binding.root, errorMessage, Snackbar.LENGTH_LONG).show()
    }

    private fun fetchForecastData() {
        weatherDataHandler.fetchWeatherForecast(
            WeatherDataHandler.ForecastType.DAILY
        )
    }

    private fun setupRecyclerView() {
        forecastAdapter = ForecastAdapter()
        binding.rvForecast.apply {
            layoutManager = LinearLayoutManager(requireContext())
            adapter = forecastAdapter
        }
    }

    private fun updateRecyclerView(dailyForecasts: List<DailyForecast>) {
        forecastAdapter?.submitList(dailyForecasts)
    }
    private fun setWeatherDataVisibility(isVisible: Boolean) {
        binding.clLoading.visibility = if (isVisible) View.INVISIBLE else View.VISIBLE
        binding.clForecastTop.visibility = if (isVisible) View.VISIBLE else View.GONE
        binding.rvForecast.visibility = if (isVisible) View.VISIBLE else View.GONE
    }
    private fun refreshForecastWeatherData() {
        setWeatherDataVisibility(false)
        fetchForecastData()
    }

    override fun onDestroyView() {
        super.onDestroyView()
        forecastAdapter = null
        viewModel.forecastData.removeObservers(viewLifecycleOwner)
        weatherDataHandler.cleanUp()
        locationRepository.removeLocationUpdates()
        _binding = null
    }
}

//    private suspend fun pruneOldDatabaseEntries(
//        getCount: suspend () -> Int,
//        deleteOldestEntry: suspend () -> Unit
//    ) {
//        val initialCount = getCount()
//        Log.i("MOH!", "Before: Total number of entries: $initialCount")
//        Log.i("MOH!", "Running on thread: ${Thread.currentThread().name}")
//
//        var currentCount = initialCount
//
//        while (currentCount > 2) {
//            deleteOldestEntry()
//            currentCount = getCount()
//        }
//
//        Log.i("MOH!", "After: Total number of entries: $currentCount")
//        Log.i("MOH!", "Running on thread: ${Thread.currentThread().name}")
//    }


//    private suspend fun pruneOldDatabaseEntries(
//        getCount: suspend () -> Int,
//        deleteOldestEntry: suspend () -> Unit
//    ) {
//        val initialCount = getCount()
//        Log.i("MOH!", "Before: Total number of entries: $initialCount")
//
//        var currentCount = initialCount
//
//        while (currentCount > 2) {
//            deleteOldestEntry()
//            currentCount = getCount()
//        }
//
//        Log.i("MOH!", "After: Total number of entries: $currentCount")
//    }